{"noir_version":"1.0.0-beta.18+99bb8b5cf33d7669adbdef096b12d80f30b4c0c9","hash":"8831605282478926645","abi":{"parameters":[{"name":"secret_base","type":{"kind":"field"},"visibility":"private"},{"name":"app_id","type":{"kind":"field"},"visibility":"public"},{"name":"scope","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"51":{"source":"use dep::poseidon::poseidon::bn254::hash_2;\n\nfn main(\n    secret_base: Field,      // private\n    app_id: pub Field,       // public\n    scope: pub Field         // public\n) -> pub Field {\n    // Derive identity secret from secret_base and app_id\n    let identity_secret = hash_2([secret_base, app_id]);\n\n    // Derive nullifier from scope and identity_secret (Semaphore v4 compatible order)\n    let nullifier = hash_2([scope, identity_secret]);\n\n    nullifier\n}\n\n#[test]\nfn test_determinism() {\n    // Same inputs should always produce the same nullifier\n    let nullifier1 = main(12345, 1, 100);\n    let nullifier2 = main(12345, 1, 100);\n    assert(nullifier1 == nullifier2);\n}\n\n#[test]\nfn test_different_secrets_produce_different_nullifiers() {\n    let nullifier1 = main(12345, 1, 100);\n    let nullifier2 = main(67890, 1, 100);\n    assert(nullifier1 != nullifier2);\n}\n\n#[test]\nfn test_different_app_ids_produce_different_nullifiers() {\n    // Same secret but different app_id should produce different nullifiers\n    let nullifier1 = main(12345, 1, 100);\n    let nullifier2 = main(12345, 2, 100);\n    assert(nullifier1 != nullifier2);\n}\n\n#[test]\nfn test_different_scopes_produce_different_nullifiers() {\n    // Same secret and app_id but different scope should produce different nullifiers\n    let nullifier1 = main(12345, 1, 100);\n    let nullifier2 = main(12345, 1, 200);\n    assert(nullifier1 != nullifier2);\n}\n\n#[test]\nfn test_known_vector() {\n    // Test with Prover.toml values - nullifier should match execute output\n    let nullifier = main(12345, 1, 100);\n    assert(nullifier == 0x10a8d64a648299a475bcb660649610f1f05501677a1affd1aaee8f549c83ab53);\n}\n\n#[test]\nfn test_zero_inputs() {\n    // Circuit should handle zero values\n    let nullifier = main(0, 0, 0);\n    // Just verify it executes without error and produces a non-zero output\n    // (Poseidon hash of zeros is not zero)\n    assert(nullifier != 0);\n}\n","path":"/Users/mikhail1/Work/soft/bring/nullifier-circuit/src/main.nr"},"56":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::poseidon::bn254::consts;\nuse crate::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"/Users/mikhail1/nargo/github.com/noir-lang/poseidon/v0.2.3/src/poseidon/bn254/perm.nr"},"57":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Creates state array with input at positions [1..N+1], then applies permutation\nfn hash_internal<let N: u32, let STATE_SIZE: u32>(\n    input: [Field; N],\n    perm_fn: fn([Field; STATE_SIZE]) -> [Field; STATE_SIZE],\n) -> Field {\n    let mut state = [0; STATE_SIZE];\n    for i in 0..N {\n        state[i + 1] = input[i];\n    }\n    perm_fn(state)[0]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    hash_internal(input, perm::x5_2)\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    hash_internal(input, perm::x5_3)\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    hash_internal(input, perm::x5_4)\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    hash_internal(input, perm::x5_5)\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    hash_internal(input, perm::x5_6)\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    hash_internal(input, perm::x5_7)\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    hash_internal(input, perm::x5_8)\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    hash_internal(input, perm::x5_9)\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    hash_internal(input, perm::x5_10)\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    hash_internal(input, perm::x5_11)\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    hash_internal(input, perm::x5_12)\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    hash_internal(input, perm::x5_13)\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    hash_internal(input, perm::x5_14)\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    hash_internal(input, perm::x5_15)\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    hash_internal(input, perm::x5_16)\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    hash_internal(input, perm::x5_17)\n}\n","path":"/Users/mikhail1/nargo/github.com/noir-lang/poseidon/v0.2.3/src/poseidon/bn254.nr"},"58":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse std::default::Default;\nuse std::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        std::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        std::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    std::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: u32,\n    capacity: u32,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, (rate + capacity) as Field);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n","path":"/Users/mikhail1/nargo/github.com/noir-lang/poseidon/v0.2.3/src/poseidon/mod.nr"}},"expression_width":{"Bounded":{"width":4}}}